#!/usr/bin/perl

sub resolve_devices;
sub is_enclosure;
sub find_shelves;


if ($#ARGV != 2) {
    print<<EOF;

Usage: shelf_light -s|-d -i|-f|-o|-l device
Where:
	-s	device is shelf (/dev/sgX)
        -d	device is drive (/dev/sgX or /dev/sdX)
	-i	turn on ident light (usually blue)
        -f	turn on failed light (usually red)
        -o	turn off all lights
        -l	show lights status (for shelf it also show status of drives\' lights)
        device	special device path. For shelf lights it must be SCSI generic for shelf. 
		For drives it can be SCSI generic of block device.

EOF
    exit;
}

# arguments
if    ($ARGV[0] eq "-s") { $shelf_mode = 1 }
elsif ($ARGV[0] eq "-d") { $shelf_mode = 0 }
else {
    print "First argument must be -d or -s\n";
    exit;
}

if    ($ARGV[1] eq "-i") { $op = "ident"  }
elsif ($ARGV[1] eq "-f") { $op = "failed" }
elsif ($ARGV[1] eq "-o") { $op = "off"    }
elsif ($ARGV[1] eq "-l") { $op = "status" }
else {
    print "Second argument must be one of -i, -f, -o or -l\n";
    exit;
}

($dev_no, $shelf_dev) = resolve_devices ($ARGV[2]);

print "$ARGV[2] -> ($dev_no, $shelf_dev)\n";

if ($shelf_dev eq "") {
    print "Your device ($ARGV[2]) is not a shelf and doesn't belong to shelf\n";
    exit;
}

if ($dev_no == -1) {
    print "Failed to find device enclosure position\n";
    exit;
}



# by given scsi generic of block device find
# object number in enclosure and scsi generic of
# enclosure which owns device (if given device
# is an enclosure itself, empty string returned)
sub resolve_devices
{
    my ($dev) = @_;

    if ($dev !~ /sg\d+$/) {     # block device. Find it's scsi generic
        open MAP, "sg_map 2>/dev/null |" || die "sg_map not found";
        while (<MAP>) {
            chomp;
            @a = split /\s+/;
            next unless $#a;
            if ($a[1] eq $dev) { $dev = $a[0]; last } 
        }
        close MAP;
    }

    return (0, $dev) if is_enclosure ($dev);

    # is it a drive in enclosure?
    # 1. find it's SAS address
    $dev =~ /(sg\d+)$/;
    $dev_name = $1;
    $lnk = readlink "/sys/class/scsi_generic/$dev_name/device";

    if ($lnk =~ /\/(end_device-\d+:\d+:\d+)\//) {
        $end = $1;
    } else {
        return (-1, "");
    }

    $sas = `cat /sys/class/sas_end_device/$end/device/sas_device:$end/sas_address`;
    chomp $sas;

    # 2. find all shelves attached
    # 3. find device with such address
    foreach $shelf (find_shelves ()) {
        open SES, "sg_ses -p 0xA $shelf 2> /dev/null |" || die "sg_ses not found";

        $disk = $res_disk = -1;

        while (<SES>) {
            chomp;
            $disk++ if /^\s*Transport protocol/;
            if (/^\s*SAS address: (0x[0-9a-f]+)\s*$/ && $1 eq $sas) {
                $res_disk = $disk;
                last;
            }
        }

        close SES;

        return ($res_disk, $shelf) if $res_disk != -1;
    }
    
    return (-1, "");
}


sub is_enclosure
{
    my ($dev) = @_;

    open SES, "sg_ses $dev 2>/dev/null |" || die "sg_ses utility not found";

    while (<SES>) {
        return 1 if /enclosure services device/;
    }

    close MAP;
    return 0;
}


sub find_shelves
{
    my @res;
    open SCSI, "/proc/scsi/scsi" || die "You must have /proc/scsi/scsi to run this!";

    $sg = -1;
    while (<SCSI>) {
        chomp;
        $sg++ if (/^Host:/);
        push @res, "/dev/sg$sg" if (/^\s*Type:\s+Enclosure/);
    }

    close SCSI;

    return @res;
}
